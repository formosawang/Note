1. 前端模块化：为了更好的处理得到想要的数据，将数据放在一个js文件里，commonJS是把这个js文件导出，在这个js文件里用module.exports来导出。在想要引用的地方用require来引入，在require的时候还可以结构出来
2. 函数的this指向，指向定义时的执行上下文，或者就是指向外层代码执行上下文
3. 重的set用法： let arr = [1, 2, 3, 4, 6, 3, 6, 7,7, 7, 2, 45, 6];       let newArr = new Set(arr)  得到结果[1, 2,  3, 4, 6, 7, 45]  
4. let o = "formosa";  console.log(Object.prototype.toString.bind(o)());  打印结果：[object String] bind只能改变this,不会执行，如果换成call,apply就可以省略后面的括号
5. 作用域链: 保存一个函数所有可用的作用域对象的链式结构(好友列表)学名就叫作用域链
6. 闭包形成的原因: 外层函数调用后，外层函数的作用域对象被内层函数引用着无法释放，形成了闭包对象
7. 作用域  用途: 一个变量的可用范围       本质: 也是一个专门保存变量的对象
8. 清除浮动最常用的是利用伪元素来清除浮动，谁浮动就给谁的父元素加伪元素，给父元素加伪元素其实就是给父元素加第一个儿子或者最后一个儿子，然后将伪元素设置为块级元素，内容为空，再清除浮动， content: "" ; display: block; clear: both;
9. 因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。 微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。  宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。
10. Pomise.all的使用：Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。
11. 什么是闭包：外层函数调用后，外层函数的作用域对象被内层函数引用着无法释放，形成了闭包对象  好处：1 创建私有变量 2使已经结束运行的函数上下文中的变量继续留在内存中， 缺点：多占用内存，使用不当会造成内存泄漏
12. 同源策略：浏览器只允许当前网页中的ajax请求使用自己网站的资源，禁止ajax请求使用其他网站的资源。 浏览器会检查网页请求回来的所有数据。尤其会检查ajax的xhr请求回来的数据。浏览器只允许来源地址和当前网页所在地址属于同一域名下的数据，进入程序中使用。一旦发现，请求回来的数据来源地址，与当前网页所在地址不一致，则浏览器禁止使用该数据
13. Ajax发送异步请求（四步操作）：1 创建异步对象（XMLHttpRequest对象）2 打开与服务器的连接 3 发送请求 4 接收服务器的响应
14. javascript 代码中的 "use strict"; 是什么意思 ? 使用它区别是什么？use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向
15. 什么是vue生命周期？  Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期
16. vue生命周期的作用是什么？ 它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑
17. vue生命周期总共有几个阶段？ 它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后
18. 第一次页面加载会触发哪几个钩子？第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子
19. DOM 渲染在 哪个周期中就已经完成？DOM 渲染在 mounted 中就已经完成了。
20. 简单描述每个周期具体适合哪些场景？生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom
21. Vue生命周期中mounted和created的区别  created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图 , mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。
